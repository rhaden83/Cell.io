Unfortunately I did not pull any formulas from papers, I just did what felt right. Which was... very confusing, to be honest.  I knew from my older Evolution Simulator that it's better if creatures can mutate quickly at the beginning when they're experimenting with new things, and slowly near the end, when they're fine-tuning. To do this, I gave each creature a "mutability" trait that told its DNA how fast it could mutate. This value could be changed as well, so that if creatures felt like they didn't want to mutate as fast anymore, they could select creatures with lower mutability to survive more.

In Evolv.io, it's the same, except that every single axon has a "mutability" trait. So some axons that still evolving can keep their mutability variables high, and other axons that are done evolving can set them low. The variable MUTABILITY_MUTABILITY tells creatures how fast they can change their mutability.

mutatePower is the "exponent" for the mutation function. When mutations occur, I want more extreme mutations to be less likely than mild ones. So, using the function mutabillity = x^5 would work, where x is a random variable from -1 to 1. But maybe a sharper curve, like x^7, would be better. I don't know. So the exponent, whether it's 5, or 7, or 9, (in this case is 9) is mutatePower. I guess the higher mutatePower is, the less frequent extreme mutations are relative to mild ones.

Finally, I have to be honest: it took me a LONG time to remember what MUTATE_MULTI was for. But now I remember. So, r() is a function that returns a random number from -1 to 1, with more extreme values being rarer as described in the previous paragraph. Suppose mutatePower is 9, like it is in the source code. If the axon's mutability variable is 62 units, then you might expect, just multiply 62 by r() to calculate that axon's mutation for that generation! Seems simple enough. But what is the range of this mutation? r() returns -1 to 1, so at the extremes, it'll be -62 to 62. However, since r() is so sharp of a function (x^9), the vast majority of the time, it'll return a value between -0.01 and 0.01. That means the "typical" mutation of this axon is -0.62 to 0.62. That's kinda confusing, when the mutation VARIABLE says "62", but typical experience is telling us "0.62", which is very different.

How does MUTATE_MULTI fix this? Well, it calculates a "typical" value r() could output, which is 0.5^mutatePower. It's not at the extremes of 1^mutatePower, but it's also not at 0. Half of all outputs of r() will be more extreme than 0.5^mutatePower, and half will be less extreme. Makes sense.
So, the "typical" value of MUTATE_MULTI when mutatePower is 9 = 0.5^9 = 0.001953.

So, if an axon's mutability is 62, and we want that to mean that that axon's typical mutation is ACTUALLY 62, then we have to divide the mutation of r()*mutability by MUTATE_MULTI to "normalize" it. Only then can we say that half of mutations are less extreme than r()*mutability/MUTATE_MULTI, and half are more extreme. This also means that if r() does output an extreme value, like 1 or -1, the axon will mutate WAY MORE than 62. But that's okay.

Another good reason to do this is that, if I decide to change mutatePower from 9 to, say, 11, iti doesn't change the typical mutation size at all, only the severity of the extremes. Under the old system, every time I'd change mutatePower, I'd also have to re-calibrate the mutation size. I guess you could say MUTATE_MULTI is "auto-calibrating" for me. 